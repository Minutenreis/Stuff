$date
	Tue Nov 15 16:10:52 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module alu_tb $end
$var wire 8 ! l_result [7:0] $end
$var wire 1 " l_carry_out $end
$var reg 8 # l_a [7:0] $end
$var reg 2 $ l_alu_ctrl [1:0] $end
$var reg 8 % l_b [7:0] $end
$scope module m_dut $end
$var wire 8 & i_a [7:0] $end
$var wire 2 ' i_alu_ctrl [1:0] $end
$var wire 8 ( i_b [7:0] $end
$var wire 8 ) l_and [7:0] $end
$var wire 8 * l_notb [7:0] $end
$var wire 8 + l_or [7:0] $end
$var wire 8 , o_result [7:0] $end
$var wire 1 " o_carry_out $end
$var wire 8 - l_mux [7:0] $end
$var wire 8 . l_adder [7:0] $end
$scope module adder_0 $end
$var wire 8 / i_a [7:0] $end
$var wire 1 0 i_carry_in $end
$var wire 8 1 o_s [7:0] $end
$var wire 1 " o_carry_out $end
$var wire 8 2 i_b [7:0] $end
$upscope $end
$scope module mux_2_0 $end
$var wire 8 3 i_in0 [7:0] $end
$var wire 8 4 i_in1 [7:0] $end
$var wire 1 5 i_s $end
$var reg 8 6 o_out [7:0] $end
$upscope $end
$scope module mux_4_0 $end
$var wire 8 7 i_in0 [7:0] $end
$var wire 8 8 i_in1 [7:0] $end
$var wire 8 9 i_in2 [7:0] $end
$var wire 8 : i_in3 [7:0] $end
$var wire 2 ; i_s [1:0] $end
$var wire 8 < o_out [7:0] $end
$var wire 8 = l_out1 [7:0] $end
$var wire 8 > l_out0 [7:0] $end
$scope module mux_2_0 $end
$var wire 8 ? i_in0 [7:0] $end
$var wire 8 @ i_in1 [7:0] $end
$var wire 1 A i_s $end
$var reg 8 B o_out [7:0] $end
$upscope $end
$scope module mux_2_1 $end
$var wire 8 C i_in0 [7:0] $end
$var wire 8 D i_in1 [7:0] $end
$var wire 1 E i_s $end
$var reg 8 F o_out [7:0] $end
$upscope $end
$scope module mux_2_2 $end
$var wire 8 G i_in0 [7:0] $end
$var wire 8 H i_in1 [7:0] $end
$var wire 1 I i_s $end
$var reg 8 J o_out [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 J
0I
b0 H
b0 G
b0 F
0E
b0 D
b0 C
b0 B
0A
b0 @
b0 ?
b0 >
b0 =
b0 <
b0 ;
b0 :
b0 9
b0 8
b0 7
b0 6
05
b11111111 4
b0 3
b0 2
b0 1
00
b0 /
b0 .
b0 -
b0 ,
b0 +
b11111111 *
b0 )
b0 (
b0 '
b0 &
b0 %
b0 $
b0 #
0"
b0 !
$end
#10
b1100010 !
b1100010 ,
b1100010 <
b1100010 J
1"
b10100101 =
b10100101 F
b10100101 H
b1100010 >
b1100010 B
b1100010 G
b1011010 *
b1011010 4
b10100101 -
b10100101 2
b10100101 6
b10100101 )
b10100101 9
b10100101 C
b10111101 +
b10111101 :
b10111101 D
b1100010 .
b1100010 1
b1100010 7
b1100010 8
b1100010 ?
b1100010 @
b10100101 %
b10100101 (
b10100101 3
b10111101 #
b10111101 &
b10111101 /
#20
b11000 !
b11000 ,
b11000 <
b11000 J
b11000 >
b11000 B
b11000 G
b1011010 -
b1011010 2
b1011010 6
b11000 .
b11000 1
b11000 7
b11000 8
b11000 ?
b11000 @
b10111101 =
b10111101 F
b10111101 H
15
10
1A
1E
b1 $
b1 '
b1 ;
#30
b1100010 >
b1100010 B
b1100010 G
b10100101 -
b10100101 2
b10100101 6
b1100010 .
b1100010 1
b1100010 7
b1100010 8
b1100010 ?
b1100010 @
b10100101 =
b10100101 F
b10100101 H
b10100101 !
b10100101 ,
b10100101 <
b10100101 J
05
00
0A
0E
1I
b10 $
b10 '
b10 ;
#40
b11000 >
b11000 B
b11000 G
b10111101 !
b10111101 ,
b10111101 <
b10111101 J
b1011010 -
b1011010 2
b1011010 6
b11000 .
b11000 1
b11000 7
b11000 8
b11000 ?
b11000 @
b10111101 =
b10111101 F
b10111101 H
15
10
1A
1E
b11 $
b11 '
b11 ;
#50
